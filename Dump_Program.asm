.MODEL SMALL
.STACK 100H
.DATA
 EMESSAGE DB 10,13, " ERROR: INVALID PARAMETERS LIST $"
 STR1  DB 256 DUP("$") 
.CODE
.386
 MAIN PROC
 
	MOV AX,@DATA
	MOV DS,AX		
	LEA SI,STR1
	PUSH SI
	CALL GET_PARAMETERS
	LEA AX, STR1
	PUSH AX
	CALL COUNT_PARAMETERS
	CMP CX,0
	JE ZERO_PARAMETER
	CMP CX,1
	JE ONE_PARAMETER
	CMP CX,2
	JE TWO_PARAMETERS
	JMP THREE_PARAMETERS
	
	ZERO_PARAMETER:
	    MOV AX,073FH
		MOV DS,AX
		MOV SI,0100H
		MOV DI,017FH
		JMP NEXT_LINE
		
	ONE_PARAMETER:
	
		MOV DI,0081H ; command line parameters starting offset address
		MOV AL,':'
		XOR CX , CX
		MOV CL, ES:[0080H] ; Length of string 
		REPNE SCASB
		CMP CX,0		   ; if cx 0 then Segment Address not given
		JE SET_ADDRESS_1        ; STORE ONLY STARTING ADDRESS
		 ; WHEN SEGMENT ADDRESS IS GIVEN
		 
			LEA SI,STR1
			INC SI
			PUSH SI
			CALL STORE_HEXA
			PUSH BX
			; TO CALCULATE THE STARTING OFFSET ADDRESS
			LEA SI,STR1
			ADD SI,6H
			PUSH SI
			CALL STORE_HEXA
			MOV SI, BX
			MOV DI,SI
			ADD DI, 7FH
			POP DS
			JMP NEXT_LINE
			
		SET_ADDRESS_1:
			LEA SI,STR1
			INC SI     ; TO SKIP SPACE IN STRING
			PUSH SI
			CALL STORE_HEXA ; TO GET HEXA ADDRESS IN BX
			MOV SI, BX      ; STARTING OFFSET ADDRESS
			MOV DI,SI
			ADD DI,7FH      ; ENDING OFFSET ADDRESS
			MOV AX,073FH    ; SEGMENT ADDRESS
			MOV DS,AX
			JMP NEXT_LINE
			
	TWO_PARAMETERS:
	
	    MOV DI,0081H ; command line parameters starting offset address
		MOV AL,':'
		XOR CX , CX
		MOV CL, ES:[0080H] ; Length of string 
		REPNE SCASB
		CMP CX,0		   ; if cx 0 then Segment Address not given
		JE SET_ADDRESS_2
		
		    ; TO GET THE SEGMENT ADDRESS
		    LEA SI,STR1
			INC SI
			PUSH SI
			CALL STORE_HEXA
			PUSH BX
			
			; TO GET THE STARTING OFFSET ADDRESS
			LEA SI,STR1
			ADD SI,6H
			PUSH SI
			CALL STORE_HEXA
			MOV SI, BX
			
			; TO GET THE ENDING OFFSET ADDRESS
            LEA AX,STR1
			ADD AX,0BH 		
            PUSH AX
			CALL STORE_HEXA
            MOV DI,BX
			POP DS    ; DATA SEGMENT ADDRESS
			JMP NEXT_LINE
		SET_ADDRESS_2:
		
			; STARTING OFFSET CALCULATION 
		    LEA SI,STR1
			INC SI     ; TO SKIP SPACE IN STRING
			PUSH SI
			CALL STORE_HEXA ; TO GET HEXA ADDRESS IN BX
			MOV SI, BX      ; STARTING OFFSET ADDRESS
			
			; ENDING OFFSET CALCULATION 
			LEA AX,STR1
			ADD AX,6H    
			PUSH AX
			CALL STORE_HEXA
			MOV DI,BX
			
			MOV AX,073FH    ; SEGMENT ADDRESS
			MOV DS,AX
			JMP NEXT_LINE
			
	THREE_PARAMETERS:
			LEA DX, EMESSAGE
			MOV AH,09H
			INT 21H
			JMP END_
	NEXT_LINE:
	CMP SI, DI
	JG END_
	PUSH DS        ; SEGMENT ADDRESS TO DISPLAY
	PUSH 04H       ; NO. OF BYTES
	CALL HEXA_OUTPUT
    MOV DL,':'
    MOV AH,02H
	INT 21H
	
	MOV BX,SI
	AND SI, 0FFF0H ; To get the offset address?
	
	PUSH SI
	PUSH 04H
	CALL HEXA_OUTPUT
		
	MOV DL,' '
    MOV AH,02H
    MOV AH,02H
	INT 21H
	INT 21H
	MOV CX,16
	
	HEX_BYTE:
		CMP SI,BX
		JL PRINT_S
		CMP SI, DI
		JG PRINT_S
		MOV AH,[SI]
		PUSH AX
		PUSH 02H
		CALL HEXA_OUTPUT
		CMP CX,9H
		JE PRINT_H
PRINT_S_NEXT:
		MOV DL,' '
		MOV AH,02H
		INT 21H
		INC SI
		LOOP HEX_BYTE
		JMP ASCII_NEXT
	 PRINT_H:
		MOV DL,'-'
		MOV AH,02H
		INT 21H
		INC SI 
		DEC CX
		JMP HEX_BYTE
	PRINT_S:
		MOV DL,' '
		MOV [SI],DL
		MOV AH,02H
		INT 21H
		INT 21H
		JMP PRINT_S_NEXT
	ASCII_NEXT:
	    MOV DL,' '
		MOV AH,02H
		INT 21H
		INT 21H
		INT 21H
		
	SUB SI,16
    MOV CX,16
	PRINT_ASCII:
		MOV DL,[SI]
		CMP DL,20H
		JL PRINT_DOT
		CMP DL,7EH
		JG PRINT_DOT
		INT 21H
		INC SI
		LOOP PRINT_ASCII
		JMP EXIT
	PRINT_DOT:
	    MOV DL,'.'
		MOV AH,02H
		INT 21H
		INC SI
		DEC CX
		JNZ PRINT_ASCII
	EXIT:
	; PRINTING NEW LINE 
	MOV DL,0DH
	INT 21H
	MOV DL,10
	INT 21H
	JMP NEXT_LINE
END_:	
	MOV AH, 4CH
	INT 21H
	MAIN ENDP
	
	HEXA_OUTPUT PROC
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH SI
		PUSH DI
		PUSH DX
		PUSH BP   ;BASE POINTER
		
		MOV BP,SP ;TO MOVE STACK POINTER TO BASE POINTER
		MOV BX,[BP+18] ; TO DISPLAY DATA
		MOV CX,[BP+16] ; BYTE TO DISPLAY
		
		HEX_PRINT:
		
			MOV DL,BH  ; HIGHER PART OF BX
			SHR DL,4 
            CMP DL, 9H
            JG LETTER
            ADD DL,30H
			JMP HEX_NEXT
			LETTER:
			    ADD DL,55
			HEX_NEXT:
				MOV AH,02H
				INT 21H
			ROL BX,4       ; TO GET NEXT CHARACTER
			LOOP HEX_PRINT	
		POP BP
		POP DX
		POP DI
		POP SI
		POP CX
		POP BX
		POP AX
		RET 4
	HEXA_OUTPUT ENDP
	
	GET_PARAMETERS PROC
	
    PUSH DS
	PUSH ES
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH BP
	
	MOV BP,SP
	MOV DI,[BP+16]
	MOV SI,80H
	
	PUSH ES
	PUSH DS
	POP ES
	POP DS
	LODSB 
	XOR CX,CX
	MOV CL,AL
	CLD 
	REP MOVSB
	POP BP
	POP DX
	POP CX
	POP BX
	POP AX
	POP ES
	POP DS
	RET 2
	GET_PARAMETERS ENDP
	
	COUNT_PARAMETERS PROC
	MOV BP,SP
	MOV SI,[BP+2]
	MOV CX, 0
	COUNT:
		LODSB 
		CMP AL,' '
		JE INCREMENT
		CMP AL,'$'
		JE EXIT_RET
		JMP COUNT
		INCREMENT:
			INC CX
		JMP COUNT
		EXIT_RET:
			RET 2
	COUNT_PARAMETERS ENDP
	
	STORE_HEXA PROC
	
		PUSH AX
		PUSH CX
		PUSH SI
		PUSH DI
		PUSH DX
		PUSH BP 
		MOV BP, SP
		
		MOV SI,[BP+12+2]
		
		XOR BX,BX
		MOV CL,4
		INPUT:
			LODSB
			CMP AL,'$'
			JE END_WHILE
			CMP AL,' '
			JE END_WHILE
			CMP AL,':'
			JE END_WHILE
			CMP AL,39H
			JG LETTER
			SUB AL,30H
			JMP SHIFT
		LETTER:
			SUB AL,37H
		SHIFT:
			AND AL, 0FH
			SHL BX,CL
			OR BL,AL
			JMP INPUT
	END_WHILE:
		POP BP
		POP DX
		POP DI
		POP SI
		POP CX
		POP AX
		RET 2
	STORE_HEXA ENDP
 END MAIN
 
 
 
 